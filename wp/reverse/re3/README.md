## re3
题目flag：

> flag{924a9ab2163d390410d0a1f670}

设计思路：

首先有一个运行时自修改代码，SMC，异或0x99，在IDA中patch即可：

```python
ads = 0x402219
end = 0x4022F8
while ads <= end:
 	patch_byte(ads, get_byte(ads)^0x99)
 	ads += 1
print "OK"
```

随后分析得到judge函数实现AES ECB模式。

密文在data段中，而key不得而知，向上分析，看到使用md5的几个函数，这里将一些数据进行了digest，最终获得key，其实这里调试也可以获得key。

最终：

```python
from Crypto.Cipher import AES
cipher = [0xBC, 0x0A, 0xAD, 0xC0, 0x14, 0x7C, 0x5E, 0xCC, 0xE0, 0xB1, 0x40, 0xBC, 0x9C, 0x51, 0xD5, 0x2B, 0x46, 0xB2, 0xB9, 0x43, 0x4D, 0xE5, 0x32, 0x4B, 0xAD, 0x7F, 0xB4, 0xB3, 0x9C, 0xDB, 0x4B, 0x5B]
key = [0xcb, 0x8d, 0x49, 0x35, 0x21, 0xb4, 0x7a, 0x4c, 0xc1, 0xae, 0x7e, 0x62, 0x22, 0x92, 0x66, 0xce]
cipher = bytes(cipher)
key = bytes(key)

aes = AES.new(key, mode=AES.MODE_ECB)
flag = aes.decrypt(cipher)
print(flag)
# flag{924a9ab2163d390410d0a1f670}
```